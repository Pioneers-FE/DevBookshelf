이번 챕터의 핵심은 원시 타입과 객체 타입이 메모리에 어떤식으로 저장되는지를 알아본 중요한 시간이었다. 두 데이터 타입에 따라 메모리에 저장되는 방식이 다르다는 것을 알게됐다.

원시타입이 할당된 변수에는 실제값이 저장된다. 반면 객체타입의 경우는 객체가 실제로 저장된 메모리 주소값이 저장된다.

### 원시타입

원시타입은 다음과 같은 매우 중요한 특징을 갖는다. 값이 변경이 불가능하다는 것이다.

이전에 값의 재할당시 메모리 공간을 덮어쓰는 것이 아니라 새로운 메모리 공간을 할당하고 그곳에 값을 쓴다는 것을 배웠다. 이런 이유는 값을 변경할 수 없었기 때문이었다. 그래서 새로운 메모리 공간을 찾아야 했던 것이다.

```jsx
var a = 'hello'
a[0] = 'j'
a // 'hello'
```

문자열도 원시타입이다. 그렇기 때문에 문자열의 값도 수정을 할 수 가 없다는 점을 알아야한다. 이 부분이 다른 언어들과 달랐던 점 같다.

```jsx
let x = 77
let y = x
```

위 코드가 실행되면 x에 있는 값이 y에 복사가 된다. 이때 77을 담는 메모리 공간이 추가로 할당되고 y는 x와 다른 77의 메모리 공간을 담당하는 식별자가 되는거다.

### 객체타입

객체타입이 할당된 변수는 객체값을 담고 있는게 아니라 객체값이 할당된 메모리 주소를 담고 있다.

```jsx
const obj = { name: 'John', data: { id: 123 } }
const obj2 = obj
```

이렇게 되면 둘은 같은 객체를 참조하게 된다.

```jsx
const obj3 = { ...obj }
```

이걸 shallow copy라고 한다. 더이상 같은 객체를 참조하지는 않는다. 하지만 객체 안에 있는 프로퍼티 `data`의 경우에 참조값이 복사된 것이기 때문에 `obj.data === obj3.data`

깊은 복사는 중첩된 객체들까지 전부 복사를 하기 때문에 완벽하게 별개의 객체가 생성되게 되는 것이다. lodash라는 라이브러리를 통해 깊은 복사를 할 수 있다.
