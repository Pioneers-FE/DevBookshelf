원시 타입 vs 객체 타입

|                | 원시 값        | 객체 값          |
| -------------- | -------------- | ---------------- |
| 변경 가능 여부 | X              | O                |
| 메모리 저장 값 | 실제 값        | 참조 값          |
| 값 전달        | 값에 의한 전달 | 참조에 의한 전달 |

### 11.1 원시 값

---

원시 값의 불변성

- 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것은 아님
- 변수 재할당 시 메모리 공간 주소가 변경되는 이유는 원시 값의 불변성 때문이다
- 상태 변경 추적 용이

문자열과 불변성

- 문자열(2바이트) → 문자가 개수에 따라 메모리 공간 크기 결정
- C, Java와 다르게 JS는 문자열을 변경 불가능한 원시 타입으로 취급
- 문자열은 유사 배열 객체이면서 이터러블이므로 각 문자 접근 가능
  - 단, 변경은 불가
  - string.length 처럼 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환

값에 의한 전달

```jsx
var score = 80;
var copy = score;
score = 100;
console.log(copy); // 80
```

- 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 전달됨
  | …                 |     |
  | ----------------- | --- |
  | 0x000000F2(score) | 80  |
  | …                 |     |
  | …                 |     |
  | ----------------- | --- |
  | 0x000000F2(score) | 80  |
  | …                 |     |
  | 0x00001332(copy)  | 80  |
  | …                 |     |
  | ----------------- | --- |
  | 0x000000F2        | 80  |
  | …                 |     |
  | 0x00001332(copy)  | 80  |
  | …                 |     |
  | 0x0669F913(score) | 100 |
- 엄밀히 말하면 값이 전달되는 게 아니라 메모리 주소가 전달되는 것임
  - 식별자 = 메모리 주소에 붙인 이름
  - `var x  = 10` 은 10이라는 값이 전달되는 게 아니라, 숫자 리터럴 10에 의해 생성된 메모리 공간이 할당되는 것

### 11.2 객체

---

객체 관리 방식

- JS 객체는 다른 객체지향 언어와 다르게 클래스 없이 동적으로 프로퍼티 추가
  - 메모리 공간을 사전에 할당할 수 없음
  - **해시 테이블**과 유사
  - 성능 향상을 위해 **히든 클래스** 방식 사용

객체의 가변성

- 변수에 객체를 할당하면 참조 값(객체가 저장된 메모리 공간의 주소)이 저장된다
  | …                  |            |
  | ------------------ | ---------- |
  | 0x000000F2(person) | 0x00001332 |
  | …                  |            |
  | 0x00001332         | {          |
      name: ‘Lee’
  } |
- 객체는 가변 값이므로, 재할당 없이 프로퍼티 추가/갱신/삭제를 할 수 있다
  | …                  |            |
  | ------------------ | ---------- |
  | 0x000000F2(person) | 0x00001332 |
  | …                  |            |
  | 0x00001332         | {          |
      name: ‘Kim’,
      age: 10
  } |
  - 단점: 여러 개의 식별자가 하나의 객체를 공유할 수 있다

얕은 복사 vs 깊은 복사

- 이중 객체인 경우, 얕은 복사 = 한 단계까지만 복사, 깊은 복사 = 중첩 객체까지 모두 복사
  ```jsx
  const o = { x: { y: 1 } };

  const c1 = { ...o }; // { x : 0x0001 } 의 형태로 저장
  console.log(c1 === o); // false
  console.log(c1.x === o.x); // true
  ```
- 원시 값 할당 = 깊은 복사, 객체 값 할당 = 얕은 복사

⇒ 깊은 복사는 `완전한 복사`다

참조에 의한 전달

<aside>
❓

아래 코드는 값에 의한 전달/참조에 의한 전달 중 어떤 방식인지 쓰고, 그 문제점을 써보자.
얕은 복사/깊은 복사 중 어떤 것인지도 써보자.

```jsx
var person = {
  name: "Lee",
};

var copy = person;
```

- 정답
  참조에 의한 전달이고 얕은 복사다. person에 할당된 참조 값이 copy에 할당된다
  즉, person과 copy가 같은 객체를 공유하고 있어 어느 한쪽이 변경되면 다른 쪽도 영향받는다.

</aside>
