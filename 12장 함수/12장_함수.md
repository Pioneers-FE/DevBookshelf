이번 장에서는 함수를 정의하는 다양한 방법들과 그 차이점들을 알아보는 시간을 갖는다.

### 함수 리터럴 (함수 표현식)

자바스크립트에서 함수도 객체다. 따라서 함수에 대한 리터럴도 존재한다. 그 말은 함수를 어떤 식별자 변수에 할당할 수 있다는 말이된다. 함수는 다른 객체와 달리 호출할 수 있다는 차이가 있다.

```jsx
var myFunc = function funcName(x, y) {
  return x * y
}

myFunc() // OK
funcName() // Error
```

`funcName`은 함수리터럴의 함수이름이다. 함수이름은 함수 안에서만 참조할 수 있는 이름이다. 함수를 호출할때는 리터럴이 할당된 함수 식별자를 사용해야한다.

> 함수이름 ≠ 함수 식별자

함수 리터럴에서 함수 이름을 생략한 익명함수로 할당해도 된다. 결국 중요한 부분은 함수 식별자라는 점이다.

### 함수 선언문

```jsx
function hello(x, y) {
  return x + y
}

hello()
```

함수 선언문은 리터럴과 같은 형태를 하고 있다. 하지만 다음과 같은 차이가 있다.

1. 함수 이름 생략 불가능
2. 변수 호이스팅과 다른 함수 호이스팅이 일어난다. 함수의 선언이 가장 위로 올라가서 선언문 이전에서도 함수를 호출할 수 있다는 특징이 있다. 변수 호이스팅과 달리 `undefined`로 초기화 되는 것이 아님.
3. 표현식이 아닌 문이기 때문에 평가 값은 undefined가 된다. 자바스크립트 엔진은 함수리터럴과 선언문의 차이를 문맥에 따라 판단한다.
4. 리터럴과 달리 함수이름으로 호출할 수 있다. 사실 내부적으로 자바스크립트 엔진이 함수이름과 같은 함수 식별자를 만들어 주는 것이다.

### Functon 생성자 함수

그냥 있다는 것만 알아두자. 쓰지 말자.

### 화살표 함수

나중에 따로 다룬다. 자주 쓰는 함수.

### 즉시 실행 함수

정의하면서 동시에 호출하는 함수로 재사용이 불가하다. 즉시실행함수는 함수 리터럴을 생성하고 호출하는 방식이기 때문에 괄호 연산자를 사용해서 함수 리터럴임을 알려야 한다.

```jsx
;(function returnThree() {
  return 3
})() // 함수 리터럴 생성 후 호출
```

```jsx
;(function returnThree() {
  return 3
})() // 함수 리터럴 생성 후 호출
```

괄호로 감싸지 않으면 함수 선언문으로 평가해서 오류를 발생시키거나 함수선언이 되고 실행은 되지 않을 수 있다.

### 콜백 함수 & 고차 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 한다. 함수의 외부에서 콜백을 전달받아 콜백을 실행하는 함수는 고차함수라고 한다.

### 순수함수

순수함수는 다음과 같은 특징을 갖고 있다.

1. 외부 상태에 의존적이지 않으며 오직 매개변수에만 의존해 값을 생성해 반환하는 함수. 그래서 같은 입력을 넣으면 항상 같은 값이 나온다.
2. 외부의 상태를 변경하지 않는함수. 전역변수를 참조하는 함수가 아니다.
3. 매개변수로 객체를 전달받지 않는 함수.

이런 순수함수들은 side effect를 방지해 프로그램의 예기치 못한 오류를 최소화 할 수 있는 함수형 프로그래밍의 핵심적인 아이디어중 하나다.

### 새롭게 알게된 사실

1. return키워드와 반환값 사이에 줄바꿈이 있으면 안된다. 자바스크립트 엔진이 세미클론을 자동삽입하기 때문이다. 따라서 다음과 같은 코드가 동작하지 않았던 것이다.

   ```jsx
   return
   ;<div>hello</div>
   ```

   이렇게 바꿔야 한다.

   ```jsx
   return <div>hello</div>
   ```

2. 자바스크립트는 멀티 패러다임 언어구나. 객체지향, 함수형 프로그래밍.
