### 13.1 스코프란?

---

식별자 선언 위치에 따라 결정되는 “다른 코드가 자신을 참조할 수 있는 유효 범위”

- `식별자 결정` 이름이 같은 두 변수 중 어느 변수를 참조할지를 결정하는 것

  → 스코프 = 유효 범위 = 식별자 결정에 사용하는 규칙 = 네임 스페이스

- 코드의 문맥 = `렉시컬 환경` = `실행 컨텍스트`
- 하나의 값은 유일한 식별자에 연결(네임 바인딩)되어야 한다
    - `var` 키워드로 선언된 변수는 같은 스코프 내 중복 선언 허용
    - `let` , `const` 같은 스코프 내 중복 선언 미허용

### 13.2 스코프의 종류

---

전역 스코프 → 어디서든 참조 가능

지역 스코프 → 자신의 지역 스코프와 하위 지역 스코프에서 유효

- **지역 = 함수 몸체 내부**

### 13.3 스코프 체인

---

```jsx
var x = 'global x';

function outer() {
	console.log(x); // global x
	
	function inner() {
		var x = 'local x';
		console.log(x); // local x
	}
	
	inner();
}

outer();
```

위 코드에서 local x가 출력되는 이유는, `스코프 체인`에 의해 참조할 변수를 검색했기 때문

- `outer` 외부 함수

  `inner` 중첩 함수

    - inner의 상위 스코프 = outer의 지역 스코프
    - 스코프 체인: 전역 스코프 ← outer 지역 스코프 ← inner 지역 스코프
- 변수 검색은 무조건 하위 → 상위다. 자식의 자산을 부모가 참조할 수 없다

### 13.4 함수 레벨 스코프

---

코드 블록이 아닌 **함수에 의해서만 지역 스코프가 생성된다**

- C, Java, … → 블록 레벨 스코프
- JS → 함수 레벨 스코프(var는 함수 내부만 스코프로 인정)
    - ES6에 도입된 let, const는 블록 레벨 스코프 지원

### 13.5 렉시컬 스코프

---

```jsx
var x = 1;

function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo(); // 1
bar(); // 1
```

위 코드의 실행결과가 1인 이유는? JS는 렉시컬 스코프(정적 스코프) 규칙을 따르고 있어서

- 동적 스코프 → 호출을 어디서
- 정적 스코프(렉시컬 스코프) → 어디서 정의 했는지에 따라 상위 스코프 결정