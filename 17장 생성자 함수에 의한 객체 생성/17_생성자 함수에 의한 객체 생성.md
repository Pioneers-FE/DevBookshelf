이번장에서는 객체를 생성하는 새로운 방법인 생성자 함수에 대해 이야기를 나눈다. 그동안 흔하게 객체 리터럴을 활용해서 객체를 생성해왔다. 이번 장에서는 해당 방식의 단점과 생성자 함수의 장점에 대한 내용이다.

### 생성자 함수를 사용하는 방법

`new` 키워드를 함수 앞에 붙여서 호출하면 된다. 자바스크립트에는 여러 빌트인 생성자 함수들이 존재한다.

```jsx
const obj123 = new Object()
obj123 // {}

const arr123 = new Array(1, 2, 3)
arr123 // [1,2,3]
```

### 생성자 함수의 장점

생성자 함수는 템플릿을 제공한다는 점에서 객체리터럴과 다른 장점이 있다.

### new 키워드를 호출했을 때 발생 하는 일

1. 인스턴스를 암묵적으로 생성하고 이를 this라는 키워드로 바인딩해서 참조할 수 있도록 한다. 이런 바인딩 과정이 없다면 this는 전역객체를 가리키게 된다.
2. 인스턴스 초기화. 이는 개발자가 직접 작성한 코드문으로 진행된다.
3. 그리고 암묵적으로 생성된 인스턴스를 리턴
   1. 만약 의도적으로 다른 객체를 반환한다면 해당 객체가 생성자 함수의 결과물로 반환
   2. 원시값을 의도적으로 반환한다면 무시되고 원래 인스턴스를 리턴
   3. 따라서 생성자 함수로 함수를 사용할 예정이면 의도적으로 값을 return하는 방법은 권장되지 않는다.

### 생성자 함수와 일반 함수?

생성자 함수의 핵심은 `new` 키워드이다. new 키워드 없이 함수가 호출된다면 일반 함수다. 그러나 내부적으로 어떻게 구분이 되는 것일까? 정답은 내부 메서드로 구분을 한다.

함수도 객체이다. 따라서 일반 객체들이 갖는 내부 슬롯, 메서드들도 갖고 있다. 하지만 일반 객체와 달리 호출할 수 있는 객체이기 때문에 특수하게 몇개를 더 갖고 있다.

1. `[[Call]]`

   일반함수로 호출되면 이 내부 메서드가 호출된다. 모든 함수는 해당 메서드를 갖는다. 모든 함수는 callable하다.

2. `[[Construct]]`

   생성자 함수로 호출된다면 이 내부 메서드가 호출된다. 해당 메서드가 있으면 constructor, 그렇지 않으면 non-constructor라고 불린다고 한다.

그래서 사실 엄밀히 말하자면 단순히 new 키워드만 붙인다고 생성자 함수로 쓸 수 있는 것이 아니다. 내부메서드 Construct를 갖고 있어야 하는 것이다.

그러면 어떤 함수가 Construct메서드를 갖고 있을까?

1. 함수선언
2. 함수 표현식
3. 클래스(사실은 함수)

그러나 ES6의 축약표현을 사용한 메서드나 Arrow function의 경우는 Construct 메서드를 갖고 있지 않기 때문에 생성자로 사용할 수 없다. 그래서 이런 non-constructor 함수에 new키워드를 붙여서 생성자 함수로 사용하려고 한다면 오류가 발생하게 된다.

```jsx
const arrow = () => {}

const a = new arrow() //Error

const obj = {
	x(){}
	y : function(){}
}

const b = new obj.x() //Error
const c = new obj.y() // ok
```

### new 키워드를 사용해서 호출했는지 아닌지 판단하는 법

생성자 함수로 만들었지만 이를 사용자에게 어떻게 강제할 수 있을까?

1. `new.target`

   해당 키워드를 사용하면 해당 함수가 new 키워드를 사용해서 생성했는지 아닌지를 파악할 수 있다. 일반함수로 호출했다면 해당 값은 undefined.

2. 스코프 세이프 생성자 패턴 `instanceof`

   하지만 1의 방식은 모든 브라우저 환경에서 제공하는 방식은 아니기 때문에 위 방식을 많이 쓴다고 한다.

실제 자바스크립트 빌트인 생성자함수가 new 키워드 없이 동작하는 것을 확인해서 내부적으로 생성자함수로 사용하도록 강제하고 있다.
