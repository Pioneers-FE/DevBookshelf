이번장은 자바스크립트 객체의 상속과 관련된 매우 중요한 개념인 프로토타입에 대해서 이야기 한다.

## 상속의 목적

공통된 부분은 상속을 받아서 쓰게 해서 불필요하게 메모리 공간을 낭비하는 일을 방지한다.

## 프로토타입 객체

어떤 객체의 상위 객체 역할을 한다. `__proto__` 프로퍼티를 통해 접근할 수 있다. 어떤 객체에 프로퍼티를 찾을 때 해당 객체에 없다면 프로토타입 객체에서 찾게 된다.

`__proto__` 객체는 다음과 같은 특징들을 갖는다.

1. 접근자 프로퍼티이다. 접근자 프로퍼티인 이유는 상호참조 사이클을 방지하기 위해 setter에서 별도로 검증하는 로직을 추가하기 위함이다.
2. 해당 프로퍼티는 상속을 통해서 사용이 된다. 객체가 직접 소유하는 프로퍼티가 아니라 `Object.prototype`의 프로퍼티를 상속해서 사용하는 것이다.
3. 그러나 `Object.prototype`을 상속해서 생성이 되지 않는 경우도 있기 때문에 직접 프로퍼티를 사용하는 것은 권장되지 않는다.

## 함수객체의 prototype 프로퍼티

함수객체에만 존재하는 prototyp 프로퍼티가 있다. 해당 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 그래서 아래 둘은 같은 것을 가리킨다.

```jsx
function hello() {}

const jello = new hello()

hello.prototype === jello.__proto__ // true
```

따라서 생성자 함수가 될 수 없는 축약형 메서드, arrow 함수의 경우에는 애초에 prototype이라는 프로퍼티가 존재하지 않는다.

## 프로토타입 객체의 constructor 프로퍼티

해당 프로퍼티는 생성자함수를 참조하고 있다. 그래서 다음과 같이 서로가 서로를 참조하게 된다 .

```jsx
hello.prototype // prototype object
jello.__proto__.constructor // hello function
jello.constructor // hello function
```

## 리터럴로 생성된 경우는?

객체를 만드는 방법은 생성자 함수 뿐만이 아니다. 그냥 단순하게 리터럴로 객체를 할당하는 경우도 있다. 이 경우에는 constructor property가 무엇을 가리킬까?

```jsx
const x = {}

x.constructor === Object // true
```

비록 생성자함수를 통해 할당한 것은 아니지만 가상의 생성자 함수가 할당된다. 이외에도 리터럴 표기법에 따라 규칙적으로 가상의 생성자 함수가 할당된다.

- 함수리터럴 : Function
- 배열리터럴 : Array

프로토타입 객체는 단독으로 존재할 수 없고 생성자함수와 쌍으로 존재한다.

## 한번 정리

1. prototype프로퍼티는 생성자 함수에 있고 객체의 프로토타입 객체가 된다.
2. constructor는 객체의 프로토타입에 있고 생성자함수를 가리킨다.

## 생성자함수의 Prototype 프로퍼티

일반함수와 생성자함수를 구분하는 기준은은 `construct`라는 내부 메서드다. 생성자함수가 생성될 때 프로토타입 객체도 같이 생성이된다.

## 객체 생성과 프로토타입 할당

객체를 생성할 때는 내부적으로 추상연산 `OrdinaryObjectCreate`가 호출된다. 이때 객체와 프로토타입이 서로 연결되게 된다.

## 프로토타입 체인과 스코프 체인

프로토타입 체인 자바스크립트가 상속을 구현할 때 쓰는 중요한 시스템이다. 체인은 인스턴스부터 시작해서 상위 프로토타입 객체로 올라가며 그 끝에는 `Object.prototype` 객체가 존재한다. 이 체인은 상위 프로토타입 프로퍼티에 대한 접근만 가능할 뿐 수정 변경은 불가하다.

반면에 스코프 체인은 프로퍼티가 아닌 식별자를 찾을 때 쓰인다. 이 둘은 별개가 아니라 서로 함께 사용된다.

## Instanceof 연산자

```jsx
객체 instanceof 생성자함수
```

이때 판단 기준은 프로토타입 객체이다. 생성자함수.prototype이 객체의 프로토타입 체인상에 나타나는 경우에 `true`로 평가된다.

## 직접상속

`Object.create` 메소드를 사용하면 프로토타입을 지정하면서 객체를 생성할 수 있다. 심지어 체인의 종점에 위치하는 객체도 만들 수 있다. 이 객체의 경우에는 어떤 프로토타입 객체도 각지 않는다.

```jsx
const x = Object.create(null)

Object.getPrototypeOf(x) // null
```

아니면 다음과 같이 객체 리터럴에서 `__proto__`프로퍼티 정의를 통해 프로토타입을 연결할 수도 있다.

```jsx
const y = {
  name: 'hello',
  __proto__: Object.prototype,
}
```

## 정적 프로퍼티/메서드

자바로 따지자면 static이다. instance에서 참조할 수 없다. 그 이유는 프로토타입 체인에 존재하지 않기 때문이다.

## 프로퍼티 순회 연산자

1. `in`

   모든 프로토타입 체인을 뒤진다. 그래서 상위 객체에 있는 프로퍼티에 대한 존재여부도 파악할 수 있다.

   ```jsx
   const x = {}

   'toString' in x // true Object.prototype에 있는 메서드
   ```

2. `for … in`

   모든 프로토타입을 뒤진다. 다만 프로퍼티 어트리뷰트 [[Enumerable]]이 true인 경우에만 순회한다.

3. `Object.keys/ values/ entries`

   이 경우는 인스턴스의 프로퍼티만 순회하기 위해서는 위의 메서드를 사용한다.
