## 34장 이터러블

### 34.1 이터레이션 프로토콜

이터레이션 프로토콜

- 이터러블 프로토콜

  이터러블 프로토콜을 준수한 객채 , for ... of 문으로 순회

  스프레드 문법과 배열 디스트럭처링 할당의 대상으로 이용 가능

- 이터레이터 프로토콜

  next 메서드 호출로 value, done 프로퍼티를 갖는 이터레이터 리절트 객체 반환

  이터레이터 프로토콜을 준수한 객체 - 이터레이터

Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.

next 메서드를 호출하면 이터레이터 리절트 객체를 반환

이터레이터 리절트 : value(현재 순회중인 이터러블의 값), done(이터러블의 순회 완료 여부)

### 34.2 빌트인 이터러블

빌트인 이터러블

- Array, String, Map, Set, TypedArray, arguments, DOM 컬렉션

### 34.3 for...of 문

- for (변수 선언문 of 이터러블) { ... }

  내부적으로 이터레이터의 next 메서드 호출하여 이터러블을 순회

- for (변수 선언문 in 이터러블) { ... }

  프로퍼티 어트리뷰트 [[Enumerable]] 값이 true 인 프로퍼티를 순회하며 열거

### 34.4 이터러블과 유사 배열 객체

유사 배열 객체이면서 이터러블 : arguments, NodeList, HTMLCollection (ES6 부터 이터러블이 도입되며 추가됨)

### 34.5 이터레이션 프로토콜의 필요성

데이터 공급자마다 각자의 순회 방식을 갖게되면 효율적이지 않다

이터레이션 프로토콜은 이를 연결하는 인터페이스 역할

### 34.6 사용자 정의 이터러블

이터레이션 프로토콜을 준수하지 않는 일반 객체를 준수하도록 구현하면 사용자 정의 이터러블이 된다.

```jsx
const fibonacci = {
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10;

    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        return { value: cur, done: cur >= max };
      },
    };
  },
};

for (const num of fibonacci) {
  console.log(num);
}
```
