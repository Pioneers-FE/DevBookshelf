## 37장 Set과 Map

### 37.1 Set

중복되지 않는 유일한 값들의 집합,

배열과의 차이

1. 동일한 값 중복 X
2. 요소 순서에 의미 X
3. 인덱스로 요소 접근 X

```jsx
// 객체 생성
const set = new Set();

const set1 = new Set([1, 2, 3, 3]); // 1,2,3

const set2 = new Set("hello"); // h,e,l,l,o

// 개수 확인
set1.size; // 3

// 요소 추가
set1.add(1).add(2).add(4); // 1,2,3,4

// 요소 존재 여부 확인
set1.has(1); // true
set1.has(5); // false

// 요소 삭제
set1.delete(1); // 2,3,4
set1.delete(5); // 2,3,4

// 요소 일괄 삭제
set1.clear(); // Set(0) {}

// 요소 순회
const set3 = new Set([1, 2, 3]);
set3.forEach((v, v2, set) => console.log(v, v2, set));
// 1, 1, Set(3) {1,2,3}
// 2, 2, Set(3) {1,2,3}
// 3, 3, Set(3) {1,2,3}

// 집합 연산
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

// 교집합
setA.intersection(setB); // Set(2) {2,4}
setB.intersection(setA); // Set(2) {2,4}

// 합집합
setA.union(setB); // Set(4) {1,2,3,4}
setB.union(setA); // Set(4) {1,2,3,4}

// 차집합
setA.difference(setB); // Set(2) {1,3}
setB.difference(setA); // Set(0) {}

// 부분 집합
setA.isSuperset(setB); // true
setB.isSuperset(setA); // false
```

### 37.2 Map

키와 값의 쌍으로 이루어진 컬렉션

객체와의 차이

1. 객체를 포함한 모든 값을 키로 사용 가능
2. 이터러블이다
3. 요소 개수 확인 (map.size)

```jsx
// 객체 생성
const map = new Map();

const map1 = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);

// 요소 개수 확인
map1.size(); // 2

// 요소 추가
map.set("key1", "value1"); // Map(1) {"key1" => "value1"}
// 중복 요소는 덮어쓰기

// 요소 취득
map.get("key1"); // value1
map.get("key2"); // undefined

// 요소 존재 여부 확인
map.has("key1"); // ture
map.has("key2"); // false

// 요소 삭제
map.delete("key1"); // 성공여부 반환 X

// 요소 일괄 삭제
map.clear;

// 요소 순회
const lee = { name: "Lee" };
const kim = { name: "Kim" };

const map2 = new Map([
  [lee, "developer"],
  [kim, "designer"],
]);

map.forEach((v, k, map) => console.log(v, k, map));
// developer { name : "Lee" } Map(2) {
//   { name : "Lee" } => "developer",
//   { name : "Kim" } => "designer"
// }
// designer { name : "Kim" } Map(2) {
//   { name : "Lee" } => "developer",
//   { name : "Kim" } => "designer"
// }
```
