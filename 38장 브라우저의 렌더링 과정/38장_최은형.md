브라우저는 어떻게 HTML, CSS, JS를 파싱해서 렌더링할까?

![image.png](attachment:f91c8e40-6363-40d9-bfbe-12b2f754aabc:image.png)

1. HTML, CSS< 이미지, 폰트 등을 서버에 요청하고 응답 받음
2. 렌더링 엔진에서 서버로부터 받은 HTML, CSS 파싱해서 DOM과 CSSOM 생성 → 렌더 트리 생성
3. 브라우저의 JS 엔진은 서버로부터 받은 JS 파싱 → AST → 바이트 코드 → 실행.(이때 변경점은 DOM이나 CSSOM에 병합)
4. 렌더 트리를 기반으로 HTML 레이아웃 계산 및 페인팅

### 38.1 요청과 응답

---

주소창 입력하는 이유 = 서버에 리소스를 요청하기 위해서

- 호스트 이름 → DNS → IP 주소 → 요청 전송
- 일반적으로 서버는 루트 요청(/)에 대해 암묵적으로 index.html을 응답한다
- ajax, REST API는 동적 파일 요청이다

### 38.2 HTTP 1.1과 HTTP 2.0

---

HTTP/1.1와 HTTP/2의 차이?

- 1.1은 기본적으로 커넥션 당 하나의 요청/응답 만 가능
- 2는 다충 요청/응답 가능

### 38.3 HTML 파싱과 DOM 생성

---

HTML(string) → 브라우저 객체(DOM)

- 바이트 코드로 받은 HTML 문서를 charset에 지정된 인코딩 방식(UTF-8) String으로 변환 → 토큰화 → 노드(토큰의 객체화) → DOM 트리
- DOM은 HTML 문서를 파싱한 결과물이다

### 38.4 CSS 파싱과 CSSOM 생성

---

HTML 태그를 순차적으로 해석하다가, link 태그를 만나면 DOM 생성을 일시 중단하고 CSS 파일을 서버에 요청한다

### 38.5 렌더 트리 생성

---

DOM + CSSOM → 렌더 트리

- 렌더 트리는 브라우저 화면에 렌더링되는 노드로만 구성

레이아웃 계산 및 리페인팅 시점

- JS에 의한 노드 추가 또는 삭제
- 뷰포트 크기 변경(브라우저 리사이즈)
- width/height, margin, padding, border, display, position, top/left/right/bottom 등의 스타일 변경

### 38.6 자바스크립트 파싱과 실행

---

(바이트 → 문자 → 토큰 → 노드) DOM, CSSOM → 렌더 트리

JS 소스코드 → 토큰 → AST → 바이트코드 → 실행

- JS 파싱과 실행은 브라우저 렌더링 엔진이 처리 X
  - JS 엔진이 처리
  - ex) V8, SpiderMonkey, JavaScriptCore
- TS, Babel, Prettier과 같은 트랜스파일러들은 AST로 만든다

### 38.7 리플로우와 이벤트

---

JS에서 DOM이나 CSSOM을 변경하는 이벤트가 발생한 경우 실행

### 38.9 script 태그의 async/defer 어트리뷰트

---

src 어트리뷰트를 통해 외부 자바스크립트를 로드하는 경우에’만’ 사용할 수 있다

```tsx
<script async src="extern.js"></script>
<script defer src="extern.js"></script>
```

- HTML 파싱과 JS 로드가 병렬로 진행
  - `async` 동시 진행되다가 로드 완료 직후 JS 실행(HTML 파싱 중단)
  - `defer` HTML 파싱 완료된 후(DOM 생성 후) JS 실행
