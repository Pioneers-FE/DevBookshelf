### 4.1 변수란 무엇인가? 왜 필요한가?

---

자바스크립트 엔진이 10 + 20을 계산하는 과정

1. 10, 20, + 를 리터럴과 연산자로 인식한다.
2. 10 + 20 표현식을 파싱한다.
3. 피연산자인 10, 20을 각각 메모리 셀에 저장한다.
4. CPU가 메모리셀을 읽어들여 만들어낸 결과(30)을 메모리 셀에 저장한다.

30을 재사용하고 싶다면 어떻게 해야할까?

- JS는 개발자의 직접적인 메모리 제어를 허용하지 않는다
- 따라서 `변수` 를 사용해 메모리를 직접 접근하지 않아도 값을 읽을 수 있게 했다.

  > **_💡_** **_변수_**
  >
  > 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

### 4.2 식별자

---

식별자로 값에 접근하는 방법

- 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어 있다.
- 식별자가 기억하는 **메모리 주소**를 통해 값에 접근
  식별자(result) → 메모리 주소(0x0669F913) → 메모리(30)
- 식별자가 함수 결과를 가져오는 과정 `const func = () => 10 + 20`
  식별자(func) → 메모리 주소 → 메모리(30)

### 4.3 변수 선언

---

변수 선언이란

- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해 값을 저장할 수 있게 ‘준비’하는 것
- JS는 `var` `let` `const` 를 만나면, 이 ‘준비’를 할 것이다.

  ❗️ 참고: var 사용이 위험한 이유는 var가 함수 레벨 스코프(전역)를 지원하기 때문이다. ES6부터 블록 레벨 스코프를 지원하는 let, const가 도입되었다.

변수 선언 과정

1. 선언 단계: 식별자를 실행 컨텍스트에 등록하고 JS 엔진에 변수의 존재를 알린다

   > **_💡_** **_실행 컨텍스트_**
   >
   > JS 엔진이 연산을 수행하는데 필요한 식별자와 스코프를 관리하는 메커니즘. 실행 컨텍스트는 변수 이름과 값을 key/value 형태로 저장하여 관리한다.

2. 초기화 단계: 메모리 공간을 확보하고 undefined를 할당해 초기화한다.

   > **_💡_** 초기화 단계를 거치지 않으면 메모리 공간에 이전에 다른 애플리케이션이 사용했던 값(garbage value)이 남아 있을 수 있다.

   ❗️ 참고: ReferenceError는 JS 엔진이 등록된 식별자를 찾을 수 없을 때 발생한다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

---

```jsx
console.log(score); // undefined

var score;
```

위 코드에서, ReferenceError가 아니라 undefined가 출력되는 이유?

- JS는 인터프리터에 의해 한줄씩 수행(in 런타임)
- 변수 선언은 런타임이 아니라 그 전 단계에서 먼저 실행된다 = 변수 호이스팅
- var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅 된다.

### 4.5 값의 할당

---

<blockquote>
 ❓ 퀴즈
 
 ```jsx
 console.log(score1, score2);

// 1번 코드
var score1;
score = 80;

// 2번 코드
var score2 = 80;

console.log(score1, score2);

````

1. 두 코드는 JS 엔진에 완전히 동일하게 수행된다. 2번 코드가 1번 코드와 동일하게 2개의 문으로 실행되는 이유는 무엇일까요?
    <details>
    <summary>정답</summary>
     변수 호이스팅에 의해 두 코드 모두 런타임 이전에 변수 선언이 이루어지기 때문이다.
    </details>
2. 위 코드의 실행 결과는?

    <details>
    <summary>정답</summary>
    ```bash
    undefined undefined
    80 80
    ```
    런타임 이전에는 변수 선언만 이루어지므로, 둘다 undefined이다.
    값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
    </details>

</blockquote>


<br/>

```jsx
console.log(score); // undefined

score = 80;
var score;

console.log(score); // 80
````

- 변수 호이스팅에 의해 값이 정상적으로 할당된다.

  ❗참고: var가 아니라 const, let일 경우 `SyntaxError: Missing initializer in const declaration` 가 발생한다.

### 4.6 값의 재할당

---

- undefined → 80
  동일한 메모리 공간에 80을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보해 그곳에 80을 재할당한다.
- undefined → 80 → 90
  메모리 공간을 3개 차지하게 되는 셈이다. 불필요한 undefined와 80은 GB에 의해 언젠가 해제된다.

  > **_💡_** **_unmanaged lang. vs managed lang._**
  >
  > - unmanaged lang) 개발자가 명시적으로 메모리를 관리해주어야 하는 언어 ex. C
  > - managed lang) GB를 내장하고 있어 자동으로 메모리를 관리해주는 언어 ex. Java, JS

### 4.7 식별자 네이밍 규칙

---

규칙

- 첫글자: 특문을 제외한 문자, \_, $
- 첫글자 이외의 글자: 특수문자를 제외한 문자, **숫자**, \_, $
- 예약어 X
- 대소문자 구별
