# 6장 데이터 타입

### 6.1 숫자 타입

---

ECMAScript의 숫자 처리 방식

- 모든 숫자를 실수(배정밀도 64비트 부동소수점 형식)로 처리
- 2, 8, 16진수 → 실수 → 10진수로 해석
  ```jsx
  var binary = 0b01000001;
  var octal = 0o0101;
  var hex = 0x41;

  console.log(binary); // 64
  console.log(octal === hex); // true
  ```

특별한 숫자 타입

- `Infinity` 양의 무한대
- `-Infinity` 음의 무한대
- `NaN` 산술 연산 불가(not-a-number)

<blockquote>
❓

퀴즈) 다음 코드의 출력값은?

```jsx
console.log(10 / 0 === Infinity);
console.log(1 * "String" === NAN);
console.log(1 * "String" === NaN);
```

<details>
<summary>정답</summary>
    
true

NAN is undefined 오류 출력

false. JS에서 어떤 값이 NaN인 경우는 서로 같지 않다고 판단한다. (https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness 참고)

</details>
    
</blockquote>

### 6.2 문자열 타입

---

문자열

- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합
- ES6부터는 백틱(``)이 추가되었다.
- 문자열을 배열, 객체로 취급하는 C나 자바와는 다르게 JS에서의 문자열은 변경 불가능한 값(immutable type)이다.

### 6.3 템플릿 리터럴

---

템플릿 리터럴이란

- ES6부터 도입된 새로운 문자열 표기법
- 런타입에 일반 문자열로 변환됨

템플릿 리터럴이 제공하는 문자열 처리 기능

- 멀티라인

<blockquote>
💡

CRLF란?

모두 개행을 의미하는 라인 피드(\n)와 캐리지 리턴(\r). 즉, CRLF(\r\n)는 커서를 맨 앞으로 이동 시키고 한 줄 개행 했다는 뜻이다. 운영체제 끼리도 개행 처리 방식이 CR이냐 LF냐로 갈리기 때문에 서로의 파일 개행을 인식하지 못하지만, 대부분의 텍스트 에디터가 이 호환성을 보장해준다.

</blockquote>
    
- JS 템플릿 리터럴은 이스케이프 문자열이 없더라도 공백을 그대로 적용 가능
- 표현식 삽입
    - +연산자는 피연산자 중 하나 이상이 문자열인 경우는 문자열 연결 연산자로 동작한다.
- 태그드 템플릿

<blockquote>
❓
    
다음 식의 출력 결과는?

```jsx
console.log("String" + 1);
var hello;
console.log(`Hello ${hello}`);
```

<details>
<summary>정답</summary>
  String1
        
Hello undefined
</details>

</blockquote>


### 6.4 불리언 타입

---

불리언 타입의 값은 true와 false 뿐이다.

### 6.5 undefined 타입

---

undefined 타입의 값은 undefined가 유일하다.

- 변수를 선언하면 암묵적으로 정의가 이루어진다.
- 변수는 ‘선언’, 함수는 ‘정의’

### 6.6 null 타입

---

null 타입의 값은 null이 유일하다.

- Null, NULL은 없음
- 의도적 부재. `변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다` 는 의미.

명시적으로 null을 반환하는 경우

- 함수가 유효한 값을 반환할 수 없는 경우
- document.querySelector 메서드가 조건에 부합하는 HTML 요소를 검색할 수 없는 경우

### 6.7 심벌 타입

---

변경 불가능한 원시 타입의 값

- 이름이 충돌할 위험이 없는 객체의 키에 사용
- Symbol 함수를 호출해 생성
  ```jsx
  const key = Symbol("key");
  const obj = {
    key: "value1",
    [key]: "value2",
  };
  console.log(obj[key]); // value2
  console.log(obj["key"]); // value1
  ```

### 6.8 객체 타입

---

자바스크립트는 객체 기반 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.

### 6.9 데이터 타입의 필요성

---

저장, 참조, 해석을 위해

1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
   - 타입에 따라 알맞은 메모리 공간을 확보해야 낭비와 손실 없이 값을 저장할 수 있다
   - 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 크기 결정
     리터럴 100 → 숫자 타입의 값으로 해석 → 8바이트 확보(8비트 셀 8개) → 100을 2진수로 저장
     - 실제로는 소수로 처리되어서 8개는 아님
2. 값을 참조할 때 한번에 읽어들일 메모리 공간의 크기를 결정하기 위해
   - 변수 score = 100인 경우, score를 숫자 타입으로 인식하기 때문에 score의 위치(선두 메모리 주소가 0x000000F2)로 부터 offset으로 8 바이트 단위를 읽음.
   - 컴파일러는 심벌 테이블에 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리
3. 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해
   - 메모리에서 읽어들인 2진수 값은 데이터 타입에 따라 다르게 해석
     0100 0001은 65 또는 ‘A’

### 6.10 동적 타이핑

---

동적 타입 언어와 정적 타입 언어

- 정적 타입 언어: 변수 타입을 사전에 선언(명시적 타입 선언), 타입 변경 불가, 컴파일 시점에 타입 체크
- 동적 타입 언어: 어떤 타입이라도 자유롭게 할당
  - `동적 타이핑` 변수 할당 시점에 타입이 결정, 재할당에 의해 동적으로 타입이 변하는 것

typeof 연산자

- 변수에 “할당된 값”의 데이터 타입을 문자열로 반환
- 변수는 기본적으로 타입을 갖지 않는다
